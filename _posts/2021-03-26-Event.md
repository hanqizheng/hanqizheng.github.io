---
layout: post
title: "事件机制三顾"
author: "Qizheng Han"
---

前端攻城狮在“攻城”之时往往有一利器那便是`事件`。 

此利器非常人所能习得之物。欲精其身，必先精其内，明其相辅相成之道。 

咳～这么说下去我怕是马上就走到文化沙漠了哈哈哈。今天呢，就来研究研究前端乃至React的事件相关机制。 

# 一顾：DOM事件机流

事件机制的历史要追溯到1988年了。

> W3C协会早在1988年就开始了DOM标准的制定，W3C DOM标准可以分为 DOM1、DOM2、DOM3 三个版本。
>
> 从 DOM2 开始，DOM 的事件传播分三个阶段进行：事件捕获阶段、处于目标阶段和事件冒泡阶段。

下面给出这三个阶段的大概定义

![](/assets/img/2021-03-26/eventProgress.png)


- 事件捕获阶段：事件对象通过目标节点的祖先 Window 传播到目标的父节点。

- 处于目标阶段：事件对象到达事件目标节点。如果`阻止事件冒泡`，那么该事件对象`将在此阶段完成后停止传播`。

- 事件冒泡阶段：事件对象以相反的顺序从目标节点的父项开始传播，从目标节点的父项开始到 Window 结束。

## 不得不说的EventTarget.addEventListener()

在写addEventListener()的时候我还有些犹豫，前缀应该写什么呢？DOMElement，Document，Window貌似都行。看了MDN的定义之后，才知道应该是`EventTarget`。

可以来品一下MDN的定义：

> The EventTarget method addEventListener() sets up a function that will be called whenever the specified event is delivered to the target. `Common targets are Element, Document, and Window`, `but the target may be any object that supports events (such as XMLHttpRequest)`.

**这里值得注意的是：**除了一些常见的例如`DOM Element`, `Document`, `Window`这类EventTarget可以绑定事件之外，还有一些"奇怪的东西"也能绑定，例如`XMLHttpRequest`。

### EventTarget.addEventListener()的参数

众所周知EventTarget.addEventListener()的前两个参数是做什么的：

- type

  A case-sensitive string representing the event type to listen for.

  一个`区分大小写`的string，标注监听的`类型`

- listener

  This must be an object implementing the EventListener interface, or a JavaScript function. 

  必须是一个实现了EventListener接口的对象或者是一个JS的函数。(这里实现一个EventListener接口的对象还挺麻烦的🤦‍♂️，暂时忽略可专抽一期研究)。我们主要在日常开发中使用的都是一个function。


其实我之前还记得第三个参数是`useCapture`但是我打开现在的mdn发现第三个参数已经变成了options？？？？

- options
  - capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。
  - once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。
  - passive: Boolean，设置为true时，表示 listener 永远不会调

## 先来自己验证一下整个事件流程

首先我们需要构造一个3层的嵌套结构。

```jsx
{% raw %}
function App() {
  return (
    <div className="bodyContainer">
      <div className="container1">
        <span className="tex1">Container 1</span>
        <div className="container2">
          <span className="tex1">Container 2</span>
          <div className="container3">
            <span className="tex1">Container 3</span>
          </div>
        </div>
      </div>
    </div>
  );
}
{% endraw %}
```

![](/assets/img/2021-03-26/initStructure.png)

分别给每个层级的div加一个`事件监听`。

```jsx
{% raw %}
import React, { useCallback, useEffect } from 'react';
import './App.css';

function App() {
  const onContainerBodyClick = useCallback(() => {
    console.log('click in container')
  }, []);

  const onContainer1Click = useCallback(() => {
    console.log('click in container 1');
  }, []);

  const onContainer2Click = useCallback(() => {
    console.log('click in container 2');
  }, []);

  const onContainer3Click = useCallback(() => {
    console.log('click in container 3');
  }, []);

  useEffect(() => {
    const $ContainerBodyEle = document.getElementById('containerBody');
    const $Container1Ele = document.getElementById('container1');
    const $Container2Ele = document.getElementById('container2');
    const $Container3Ele = document.getElementById('container3');

    $ContainerBodyEle.addEventListener('click', onContainerBodyClick);
    $Container1Ele.addEventListener('click', onContainer1Click);
    $Container2Ele.addEventListener('click', onContainer2Click);
    $Container3Ele.addEventListener('click', onContainer3Click);

    return () => {
      $ContainerBodyEle.removeEventListener('click', onContainerBodyClick);
      $Container1Ele.removeEventListener('click', onContainer1Click);
      $Container2Ele.removeEventListener('click', onContainer2Click);
      $Container3Ele.removeEventListener('click', onContainer3Click);
    }
  }, [onContainerBodyClick, onContainer1Click, onContainer2Click, onContainer3Click]);


  return (
    <div id="containerBody" className="bodyContainer">
      <div id="container1" className="container1">
        <span className="tex1">Container 1</span>
        <div id="container2" className="container2">
          <span className="tex1">Container 2</span>
          <div id="container3" className="container3">
            <span className="tex1">Container 3</span>
          </div>
        </div>
      </div>
    </div>
  );
}

export default App;
{% endraw %}
```

点击最外层

![](/assets/img/2021-03-26/clickContainerBody.gif)

点击Container1

![](/assets/img/2021-03-26/clickContainer1.gif)

点击Container2

![](/assets/img/2021-03-26/clickContainer2.gif)

点击Container3

![](/assets/img/2021-03-26/clickContainer3.gif)


**因为是验证所以想把过程贴的详细一些，就把每次的截图都贴出来了。**

可以看到如果按照之前我们所说的`冒泡机制`，我们的输出结果是完全符合的。

![](/assets/img/2021-03-26/draw1.png)

### 这时候我想看看options里的capture属性和useCapture有什么区别？

我们在Container2上分别设置下`options: { capture: true }`和`useCapture: true`。

```js
$Container2Ele.addEventListener('click', onContainer2Click, { capture: true });

$Container2Ele.addEventListener('click', onContainer2Click, true);
```

发现打印的结果都如下

![](/assets/img/2021-03-26/capture.png)

查看DOM的事件监听发现最终都体现为这个样子

![](/assets/img/2021-03-26/checkCapture.png)

所以我的结论是，options中的`capture属性`和`useCapture`配置的是同一个功能。将`Container2`的事件在捕获阶段就执行，所以最先打印的是`click in container 2`。

![](/assets/img/2021-03-26/draw2.png)


# 二顾：React的Synthetic Event

在介绍完最基本的DOM的事件流向机制之后，我们来学习一下React的事件机制。

首先我们先把之前的例子改成React中的事件写法

```jsx
{% raw %}
import React, { useCallback, useEffect } from 'react';
import './App.css';

function App() {
  const onContainerBodyClick =() => {
    console.log('react container')
  }

  const onContainer1Click = () => {
    console.log('react container 1');
  }

  const onContainer2Click = () => {
    console.log('react container 2');
  }

  const onContainer3Click =() => {
    console.log('react container 3');
  };

  return (
    <div id="containerBody" className="bodyContainer" onClick={onContainerBodyClick}>
      <div id="container1" className="container1" onClick={onContainer1Click}>
        <span className="tex1">Container 1</span>
        <div id="container2" className="container2" onClick={onContainer2Click}>
          <span className="tex1">Container 2</span>
          <div id="container3" className="container3" onClick={onContainer3Click}>
            <span className="tex1">Container 3</span>
          </div>
        </div>
      </div>
    </div>
  );
}

export default App;
{% endraw %}
```
然后点击`Container 3`打印结果如下

![](/assets/img/2021-03-26/reactEvent.png)

效果和DOM的事件打印出来`一摸一样`。但是真的是一摸一样吗？？？

这个时候把React事件和DOM事件`同时绑定`到对应的元素上。

![](/assets/img/2021-03-26/both.png)

**这个时候区别瞬间就出来了！**



`React的事件`全部都是`晚于DOM事件`的执行。

为什么React的事件全部都会晚于DOM事件的执行呢？

## SyntheticEvent

`SyntheticEvent`是一个`类`，这个类实例出来的对象是一个`合成事件`，顾名思义`SyntheticEvent`是有`合成之意`的，为什么会有合成的意思我们需要从React的事件机制来聊起。

我们都知道React会把事件代理到`document`上(< React v17.x)，如图

![](/assets/img/2021-03-26/react16EventConcept.png)

其实可以根据这张图把React的事件机制统一成一句话

**React提供了一种“顶层注册，事件收集，统一触发”的事件机制。**

## 事件绑定

其实仔细关注一下我们是如何注册一个`React事件的`

```jsx
{% raw %}
<div id="container1" className="container1" onClick={onContainer1Click}>
{% endraw %}
```

`onClick`其实是一个`prop`，而我们的事件函数`onContainer1Click`是通过传参的方式传到了组件(其实是fiber节点，但是我对fiber的了解很少，所以这里没办法展开讲)。

`事件注册`其实就是将我们在JSX中所编写的事件相关的操作`绑定`到document上的一种操作。

而`事件绑定`主要是在初始化DOM的事件(当然DOM更新的时候也会有，但我们这里不讨论)。在初始化的时候会调用一个方法叫做`setInitialDOMProperties()`

```ts
function setInitialDOMProperties(
  tag: string,
  domElement: Element,
  rootContainerElement: Element | Document,
  nextProps: Object,
  isCustomComponentTag: boolean,
): void {
  for (const propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      ...
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
        // 如果propKey属于事件类型，则进行事件绑定
        ensureListeningTo(rootContainerElement, propKey, domElement);
      }
    }
  }
}
```
可以看到这个方法中`registrationNameDependencies`，这里判断某个`propKey`是否在`registrationNameDependencies`中，`registrationNameDependencies`是一个对象，存储了所有React事件对应的原生DOM事件的集合。

如果是事件类型的prop，那么将会调用`ensureListeningTo()`去绑定事件。
)

```js
function ensureListeningTo(rootContainerElement, registrationName, domElement) {
  const isDocumentOrFragment =
    rootContainerElement.nodeType === DOCUMENT_NODE ||
    rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE
  const doc = isDocumentOrFragment
    ? rootContainerElement
    : rootContainerElement.ownerDocument
  listenTo(registrationName, doc)
}
```

可以简单的理解为`ensureListeningTo`就是去`完成事件绑定`这步操作的。



## 完成绑定之后的监听

第一步`绑定`完成之后，把绑定到对应位置的`监听函数`叫做`listener`。但这个`listener`并不是我们在组件里所写的那一个函数，而是一个通过`createEventListenerWrapperWithPriority()`包裹生成的函数。

在看这个这么长名字的函数其实已经明白这个函数是做什么的了。`创建一个有优先级eventListener包裹器`。

**其实`不同的事件`都有各自`不同的优先级`。**

- `DiscreteEvent` 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的

- `UserBlockingEvent` 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会'阻塞'用户的交互。


- `ContinuousEvent` 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.

### 值得补充

到现在位置我们遗漏了一个知识点，就是我们改怎么`区分事件执行阶段`呢？

在`事件注册`(事件绑定)的时候我们可以通过区分`onClick` or `onClickCapture`来区分是在该事件是以`捕获阶段`的顺序执行还是`冒泡阶段`的顺序执行。

但是到了`真正执行事件`的时候呢？我们已经把对应的事件函数通过`createEventListenerWrapperWithPriority()`包裹了，并不是我们本身的那个事件处理函数了。

这时候`createEventListenerWrapperWithPriority()`包裹形成的函数本身接受一个参数`eventSystemFlags`用于区分系统各个阶段。

比如`eventSystemFlags`其中一个标记叫`IS_CAPTURE_PHASE`表明了当前的事件是捕获阶段触发。当事件名含有`Capture`后缀时，`eventSystemFlags`会被赋值为`IS_CAPTURE_PHASE`。

可以看这张图

![](/assets/img/2021-03-26/eventSystemFalges.png)

## 最后的事件触发

## 回到我们的Demo

现





# 三顾：一些值得注意的点





# 参考

- [EventTarget.addEventListener() - mdn](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
- [SyntheticEvent](https://reactjs.org/docs/events.html#gatsby-focus-wrapper)
- [Handling Events](https://reactjs.org/docs/handling-events.html)
- [React 中阻止事件冒泡的问题](https://www.cnblogs.com/Wayou/p/react_event_issue.html)
- [深入理解React：事件机制原理](https://www.cnblogs.com/forcheng/p/13187388.html)
- [深入React合成事件机制原理](https://segmentfault.com/a/1190000039108951)
- [事件绑定](https://react.jokcy.me/book/features/event-bind.html)